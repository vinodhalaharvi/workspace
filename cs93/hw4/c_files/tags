!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFLEN	command.c	8;"	d	file:
INSTYPE	lib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	g
INSTYPE	lib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	t	typeref:enum:INSTYPE
ITYPE	lib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
J	lib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
MAX_SYMBOL_SIZE	lib.h	5;"	d
MEMORY_START_ADDRESS	lib.h	6;"	d
MIF_FILE_SIZE	lib.h	4;"	d
REG_IOBUFFER_1	assembler.c	178;"	d	file:
REG_IOBUFFER_2	assembler.c	179;"	d	file:
REG_IOCONTROL	assembler.c	177;"	d	file:
RTYPE	lib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
STACK_BASE	assembler.c	176;"	d	file:
_GNU_SOURCE	assembler.c	5;"	d	file:
_break	command.c	/^char * _break(char * tokens[]){$/;"	f
_div	command.c	/^char * _div(char * tokens[]){$/;"	f
_encoding	lib.h	/^typedef struct _encoding { $/;"	s
_inst	lib.h	/^typedef struct _inst { $/;"	s
_inst_info	lib.h	/^typedef struct _inst_info {$/;"	s
_register	lib.h	/^typedef struct _register {$/;"	s
_symbol_table	lib.h	/^typedef struct _symbol_table {$/;"	s
add	command.c	/^char * add(char * tokens[]){$/;"	f
addi	command.c	/^char * addi(char * tokens[]){$/;"	f
addiu	command.c	/^char * addiu(char * tokens[]){$/;"	f
addu	command.c	/^char * addu(char * tokens[]){$/;"	f
aluopcodebits	lib.h	/^	char * aluopcodebits; $/;"	m	struct:_inst
and	command.c	/^char * and(char * tokens[]){$/;"	f
andi	command.c	/^char * andi(char * tokens[]){$/;"	f
beq	command.c	/^char * beq(char * tokens[]){$/;"	f
bgez	command.c	/^char * bgez(char * tokens[]){$/;"	f
bgezal	command.c	/^char * bgezal(char * tokens[]){$/;"	f
bgtz	command.c	/^char * bgtz(char * tokens[]){$/;"	f
bin16toint	lib.c	/^unsigned int  bin16toint(char * bits){$/;"	f
bin32toint	lib.c	/^unsigned int bin32toint(char * bits){$/;"	f
binary	lib.h	/^	char * binary; $/;"	m	struct:_encoding
binaryToHex	lib.c	/^char * binaryToHex(char * binary){$/;"	f
blez	command.c	/^char * blez(char * tokens[]){$/;"	f
bltz	command.c	/^char * bltz(char * tokens[]){$/;"	f
bltzal	command.c	/^char * bltzal(char * tokens[]){$/;"	f
bne	command.c	/^char * bne(char * tokens[]){$/;"	f
cleanLine	lib.c	/^void cleanLine(char **lineptr){$/;"	f
copz	command.c	/^char * copz(char * tokens[]){$/;"	f
divu	command.c	/^char * divu(char * tokens[]){$/;"	f
do_first_pass	assembler.c	/^void do_first_pass(int argc, const char *argv[]){$/;"	f
do_second_pass	assembler.c	/^void do_second_pass(int argc, const char *argv[]){$/;"	f
dump_sym_table	lib.c	/^unsigned dump_sym_table(){$/;"	f
encoding	lib.h	/^} encoding; $/;"	t	typeref:struct:_encoding
encoding_data	lib.h	/^static encoding encoding_data[] = { $/;"	v
eval_exp	lib.c	/^int eval_exp(char *expWithParen, int *error)$/;"	f
eval_register	lib.c	/^char * eval_register(char *expWithParen)$/;"	f
exitOnNull	lib.c	/^void exitOnNull(void * ptr, char * msg){$/;"	f
filter	lib.c	/^int filter(char **lineptr){$/;"	f
found_sym	lib.c	/^unsigned found_sym(const char * name) {$/;"	f
function_type	lib.h	/^typedef char * (*function_type)(char *[]); $/;"	t
getAluOpcodeBits	lib.c	/^char * getAluOpcodeBits(char *name){$/;"	f
getBits	lib.c	/^char * getBits(int num, unsigned int SIZE) { $/;"	f
getFiles	lib.c	/^void getFiles(int argc, const char * argv[], FILE **rfile, FILE **MIFfile){$/;"	f
getFunc	assembler.c	/^function_type getFunc(const char * name){$/;"	f
getHexBits	lib.c	/^char * getHexBits(char * binary, int size){$/;"	f
getOpcodebits	lib.c	/^char * getOpcodebits(char *name){$/;"	f
getRegisterBits	lib.c	/^char * getRegisterBits(char *registername){$/;"	f
getTokens	lib.c	/^void getTokens(const char * line, char * tokens[]){$/;"	f
get_sym_address	lib.c	/^unsigned int get_sym_address(const char * name){$/;"	f
getasciiz	lib.c	/^char * getasciiz(const char *input){$/;"	f
getlabel	lib.c	/^char * getlabel(const char *string){$/;"	f
hex	lib.h	/^	char * hex; $/;"	m	struct:_encoding
hextoint	lib.c	/^unsigned int hextoint(char * hex){$/;"	f
higher_byte	lib.c	/^int higher_byte(int word16bit) {$/;"	f
highertoint	lib.c	/^unsigned int highertoint(char * bits){$/;"	f
ifParen	lib.c	/^unsigned int ifParen(const char *exp){$/;"	f
index	lib.h	/^	unsigned int index; $/;"	m	struct:_symbol_table
inst	lib.h	/^} inst; $/;"	t	typeref:struct:_inst
inst_data	lib.h	/^static inst inst_data[100] = {$/;"	v
inst_info	lib.h	/^} inst_info;$/;"	t	typeref:struct:_inst_info
inst_table	lib.h	/^struct inst_table {$/;"	s
instname	lib.h	/^	char * instname; $/;"	m	struct:_inst
insts	assembler.c	/^struct inst_table insts[] = {$/;"	v	typeref:struct:inst_table
isValidInt	assembler.c	/^int isValidInt(const char *str, int base, int *value)$/;"	f
is_in_skip_list	assembler.c	/^int is_in_skip_list(char *sym){$/;"	f
is_valid_inst	assembler.c	/^unsigned int is_valid_inst(const char *line){$/;"	f
isasciiz	lib.c	/^int isasciiz(const char * string){$/;"	f
isempty	lib.c	/^int isempty(const char *string){$/;"	f
islabel	lib.c	/^int islabel(const char * string){$/;"	f
j	command.c	/^char * j(char * tokens[]){$/;"	f
jal	command.c	/^char * jal(char * tokens[]){$/;"	f
jalr	command.c	/^char * jalr(char * tokens[]){$/;"	f
jr	command.c	/^char * jr(char * tokens[]){$/;"	f
la	command.c	/^char * la(char * tokens[]){$/;"	f
lb	command.c	/^char * lb(char * tokens[]){$/;"	f
lbu	command.c	/^char * lbu(char * tokens[]){$/;"	f
lh	command.c	/^char * lh(char * tokens[]){$/;"	f
lhu	command.c	/^char * lhu(char * tokens[]){$/;"	f
lineno	lib.h	/^static unsigned int lineno; $/;"	v
locptr	lib.h	/^static unsigned int locptr; $/;"	v
lower_byte	lib.c	/^int lower_byte(int word16bit){$/;"	f
lowertoint	lib.c	/^unsigned int lowertoint(char * bits){$/;"	f
lui	command.c	/^char * lui(char * tokens[]){$/;"	f
lw	command.c	/^char * lw(char * tokens[]){$/;"	f
lwcz	command.c	/^char * lwcz(char * tokens[]){$/;"	f
lwl	command.c	/^char * lwl(char * tokens[]){$/;"	f
lwr	command.c	/^char * lwr(char * tokens[]){$/;"	f
main	assembler.c	/^int main(int argc, const char *argv[])$/;"	f
memory	lib.h	/^static uint16_t memory[MIF_FILE_SIZE];	$/;"	v
mfhi	command.c	/^char * mfhi(char * tokens[]){$/;"	f
mflo	command.c	/^char * mflo(char * tokens[]){$/;"	f
mthi	command.c	/^char * mthi(char * tokens[]){$/;"	f
mtlo	command.c	/^char * mtlo(char * tokens[]){$/;"	f
mult	command.c	/^char * mult(char * tokens[]){$/;"	f
multu	command.c	/^char * multu(char * tokens[]){$/;"	f
name	lib.h	/^	char * name; $/;"	m	struct:_inst_info
name	lib.h	/^	char * name; $/;"	m	struct:_symbol_table
name	lib.h	/^	char * name;$/;"	m	struct:inst_table
newstr	lib.c	/^char * newstr(int len){$/;"	f
nop	command.c	/^char * nop(char * tokens[]){$/;"	f
nor	command.c	/^char * nor(char * tokens[]){$/;"	f
opcodebits	lib.h	/^	char * opcodebits; $/;"	m	struct:_inst
or	command.c	/^char * or(char * tokens[]){$/;"	f
ori	command.c	/^char * ori(char * tokens[]){$/;"	f
outputMIFfile	lib.c	/^void outputMIFfile(FILE *MIFfile) {$/;"	f
printHeaders	lib.c	/^void printHeaders(FILE *MIFfile){$/;"	f
printSymbolInfo	lib.c	/^void printSymbolInfo(char * tokens[]) {$/;"	f
printTail	lib.c	/^void printTail(FILE *MIFfile){$/;"	f
processLine	assembler.c	/^char *  processLine(char * line, FILE *rfile, FILE *MIFfile){$/;"	f
ptr	lib.h	/^	char * (*ptr)(char *[]);$/;"	m	struct:inst_table
ptr	lib.h	/^void (*ptr)(int, int);$/;"	v
put_sym	lib.c	/^unsigned put_sym(const char * name, unsigned int lineno){$/;"	f
rdest	lib.h	/^	char * rdest; $/;"	m	struct:_inst_info
reg	lib.h	/^} reg; $/;"	t	typeref:struct:_register
register_data	lib.h	/^static reg register_data[] =  {$/;"	v
register_name	lib.c	/^char * register_name(char * input){$/;"	f
register_offset	lib.c	/^int register_offset(char * input){$/;"	f
registerbits	lib.h	/^	char * registerbits; $/;"	m	struct:_register
registername	lib.h	/^	char * registername; $/;"	m	struct:_register
registernumber	lib.h	/^	char * registernumber; $/;"	m	struct:_register
removeSpaces	lib.c	/^char * removeSpaces(const char * s) {$/;"	f
rsrc	lib.h	/^	char * rsrc; $/;"	m	struct:_inst_info
sb	command.c	/^char * sb(char * tokens[]){$/;"	f
sh	command.c	/^char * sh(char * tokens[]){$/;"	f
sli	assembler.c	/^static unsigned int sli;$/;"	v	file:
sll	command.c	/^char * sll(char * tokens[]){$/;"	f
sllv	command.c	/^char * sllv(char * tokens[]){$/;"	f
slt	command.c	/^char * slt(char * tokens[]){$/;"	f
slti	command.c	/^char * slti(char * tokens[]){$/;"	f
sltiu	command.c	/^char * sltiu(char * tokens[]){$/;"	f
sltu	command.c	/^char * sltu(char * tokens[]){$/;"	f
sp	assembler.c	/^static int sp = STACK_BASE; $/;"	v	file:
sra	command.c	/^char * sra(char * tokens[]){$/;"	f
srav	command.c	/^char * srav(char * tokens[]){$/;"	f
srl	command.c	/^char * srl(char * tokens[]){$/;"	f
srlv	command.c	/^char * srlv(char * tokens[]){$/;"	f
store_string	assembler.c	/^int store_string(char *str){$/;"	f
sub	command.c	/^char * sub(char * tokens[]){$/;"	f
subu	command.c	/^char * subu(char * tokens[]){$/;"	f
sw	command.c	/^char * sw(char * tokens[]){$/;"	f
swcz	command.c	/^char * swcz(char * tokens[]){$/;"	f
swl	command.c	/^char * swl(char * tokens[]){$/;"	f
swr	command.c	/^char * swr(char * tokens[]){$/;"	f
sym_skip_list	assembler.c	/^static char *sym_skip_list[100] = {$/;"	v	file:
symbol_table	lib.h	/^} symbol_table;$/;"	t	typeref:struct:_symbol_table
symbols	lib.h	/^static symbol_table symbols[MAX_SYMBOL_SIZE]; $/;"	v
symmaxindex	lib.h	/^static unsigned int symmaxindex; $/;"	v
syscall	command.c	/^char * syscall(char * tokens[]){$/;"	f
type2	command.c	/^char * type2(char * arg0, char * arg1){$/;"	f
type3	command.c	/^char * type3(char * arg0, char * arg1, char * arg2){$/;"	f
type4	command.c	/^char * type4(char * arg0, char * arg1, char *arg2, char *arg3){$/;"	f
type5	command.c	/^char * type5(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4){$/;"	f
type6	command.c	/^char * type6(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4, char *arg5){$/;"	f
verify_atoi	command.c	/^int verify_atoi(char *token){$/;"	f
xor	command.c	/^char * xor(char * tokens[]){$/;"	f
xori	command.c	/^char * xori(char * tokens[]){$/;"	f
