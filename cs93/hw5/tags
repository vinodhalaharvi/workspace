!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFLEN	ascommand.c	8;"	d	file:
HEAP_BASE	aslib.h	12;"	d
HEAP_BASE	emcommand.h	12;"	d
INSTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	g
INSTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	t	typeref:enum:INSTYPE
ITYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
J	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
MAX_SYMBOL_SIZE	aslib.h	6;"	d
MIF_FILE_SIZE	aslib.h	5;"	d
MIF_FILE_SIZE	emcommand.h	1;"	d
REG_IOBUFFER_1	aslib.h	9;"	d
REG_IOBUFFER_1	emcommand.h	9;"	d
REG_IOBUFFER_2	aslib.h	10;"	d
REG_IOBUFFER_2	emcommand.h	10;"	d
REG_IOCONTROL	aslib.h	8;"	d
REG_IOCONTROL	emcommand.h	8;"	d
RTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
STACK_BASE	aslib.h	11;"	d
STACK_BASE	emcommand.h	11;"	d
_GNU_SOURCE	assembler.c	5;"	d	file:
_encoding	aslib.h	/^typedef struct _encoding { $/;"	s
_inst	aslib.h	/^typedef struct _inst { $/;"	s
_inst_info	aslib.h	/^typedef struct _inst_info {$/;"	s
_location	emcommand.c	/^typedef struct _location {$/;"	s	file:
_register	aslib.h	/^typedef struct _register {$/;"	s
_symbol_table	aslib.h	/^typedef struct _symbol_table {$/;"	s
add	ascommand.c	/^char * add(char * tokens[]){$/;"	f
add	emcommand.c	/^int add(int rs, int rt, int rd){$/;"	f
addi	ascommand.c	/^char * addi(char * tokens[]){$/;"	f
addi	emcommand.c	/^int addi(int rs, int rt, int imm){$/;"	f
align4	assembler.c	/^int  align4(int address){$/;"	f
aluopcodebits	aslib.h	/^	char * aluopcodebits; $/;"	m	struct:_inst
and	ascommand.c	/^char * and(char * tokens[]){$/;"	f
and	emcommand.c	/^int and(int rs, int rt, int rd){$/;"	f
andi	ascommand.c	/^char * andi(char * tokens[]){$/;"	f
andi	emcommand.c	/^int andi(int rs, int rt, int imm){$/;"	f
beq	ascommand.c	/^char * beq(char * tokens[]){$/;"	f
beq	emcommand.c	/^int beq(int rs, int rt, int offset){$/;"	f
bin16toint	aslib.c	/^unsigned int  bin16toint(char * bits){$/;"	f
bin32toint	aslib.c	/^unsigned int bin32toint(char * bits){$/;"	f
binary	aslib.h	/^	char * binary; $/;"	m	struct:_encoding
binaryToHex	aslib.c	/^char * binaryToHex(char * binary){$/;"	f
bne	ascommand.c	/^char * bne(char * tokens[]){$/;"	f
bne	emcommand.c	/^int bne(int rs, int rt, int offset){$/;"	f
cleanLine	aslib.c	/^void cleanLine(char **lineptr){$/;"	f
command	emcommand.c	/^location command = {.x = 20, .y = 0}; $/;"	v
currInst	emulator.c	/^char currInst[100];$/;"	v
do_first_pass	assembler.c	/^void do_first_pass(int argc, const char *argv[]){$/;"	f
do_second_pass	assembler.c	/^void do_second_pass(int argc, const char *argv[]){$/;"	f
doinst	emcommand.c	/^int doinst(char * inst){$/;"	f
dump_memory	aslib.c	/^void dump_memory() { $/;"	f
dump_sym_table	aslib.c	/^unsigned dump_sym_table(){$/;"	f
encoding	aslib.h	/^} encoding; $/;"	t	typeref:struct:_encoding
encoding_data	aslib.h	/^static encoding encoding_data[] = { $/;"	v
eval_exp	aslib.c	/^int eval_exp(char *expWithParen, int *error)$/;"	f
eval_register	aslib.c	/^char * eval_register(char *expWithParen)$/;"	f
exitOnNull	aslib.c	/^void exitOnNull(void * ptr, char * msg){$/;"	f
filter	aslib.c	/^int filter(char **lineptr){$/;"	f
found_sym	aslib.c	/^unsigned found_sym(const char * name) {$/;"	f
function_type	aslib.h	/^typedef char * (*function_type)(char *[]); $/;"	t
getAluOpcodeBits	aslib.c	/^char * getAluOpcodeBits(char *name){$/;"	f
getBits	aslib.c	/^char * getBits(int num, unsigned int SIZE) { $/;"	f
getBits	emcommand.c	/^char * getBits(int num, unsigned int SIZE) { $/;"	f
getFiles	aslib.c	/^void getFiles(int argc, const char * argv[], $/;"	f
getFiles	emulator.c	/^void getFiles(int argc, const char * argv[], FILE **rfile){$/;"	f
getFunc	assembler.c	/^function_type getFunc(const char * name){$/;"	f
getInstName	assembler.c	/^char * getInstName(const char *line){$/;"	f
getOpcodebits	aslib.c	/^char * getOpcodebits(char *name){$/;"	f
getRegisterBits	aslib.c	/^char * getRegisterBits(char *registername){$/;"	f
getTokens	aslib.c	/^void getTokens(const char * line, char * tokens[]){$/;"	f
get_string_from_memory	assembler.c	/^char * get_string_from_memory(int address){$/;"	f
get_sym_address	aslib.c	/^unsigned int get_sym_address(const char * name){$/;"	f
getasciiz	aslib.c	/^char * getasciiz(const char *input){$/;"	f
getheapStr	emcommand.c	/^char * getheapStr(){$/;"	f
getheapStrOutput	emcommand.c	/^char * getheapStrOutput(const char * str, int i){$/;"	f
getlabel	aslib.c	/^char * getlabel(const char *string){$/;"	f
hex	aslib.h	/^	char * hex; $/;"	m	struct:_encoding
hextoint	aslib.c	/^unsigned int hextoint(char * hex){$/;"	f
hextoint	emcommand.c	/^unsigned int hextoint(char * hex){$/;"	f
higher_16_byte	aslib.c	/^int higher_16_byte(int word32bit) {$/;"	f
higher_byte	aslib.c	/^int higher_byte(int word16bit) {$/;"	f
highertoint	aslib.c	/^unsigned int highertoint(char * bits){$/;"	f
hp	assembler.c	/^static int hp = HEAP_BASE; $/;"	v	file:
hp	emcommand.c	/^int hp = HEAP_BASE; $/;"	v
ifParen	aslib.c	/^unsigned int ifParen(const char *exp){$/;"	f
immint	emcommand.c	/^unsigned int immint(char * bits){$/;"	f
index	aslib.h	/^	unsigned int index; $/;"	m	struct:_symbol_table
init_registers	emcommand.c	/^void init_registers(){$/;"	f
inst	aslib.h	/^} inst; $/;"	t	typeref:struct:_inst
inst_data	aslib.h	/^static inst inst_data[100] = {$/;"	v
inst_info	aslib.h	/^} inst_info;$/;"	t	typeref:struct:_inst_info
inst_table	aslib.h	/^struct inst_table {$/;"	s
instcountlocation	emcommand.c	/^location instcountlocation = {.x = 28, .y = 0}; $/;"	v
instcountstring	emcommand.c	/^void instcountstring(const char *str){$/;"	f
instint	emcommand.c	/^unsigned int instint(char * bits){$/;"	f
instname	aslib.h	/^	char * instname; $/;"	m	struct:_inst
insts	assembler.c	/^struct inst_table insts[] = {$/;"	v	typeref:struct:inst_table
ir	emcommand.c	/^unsigned int ir; $/;"	v
isValidInt	assembler.c	/^int isValidInt(const char *str, int base, int *value)$/;"	f
is_in_skip_list	assembler.c	/^int is_in_skip_list(char *sym){$/;"	f
is_valid_inst	assembler.c	/^unsigned int is_valid_inst(const char *line){$/;"	f
isasciiz	aslib.c	/^int isasciiz(const char * string){$/;"	f
isempty	aslib.c	/^int isempty(const char *string){$/;"	f
islabel	aslib.c	/^int islabel(const char * string){$/;"	f
j	ascommand.c	/^char * j(char * tokens[]){$/;"	f
j	emcommand.c	/^int j(int inst_index){$/;"	f
jal	ascommand.c	/^char * jal(char * tokens[]){$/;"	f
jal	emcommand.c	/^int jal(int inst_index){$/;"	f
jr	ascommand.c	/^char * jr(char * tokens[]){$/;"	f
jr	emcommand.c	/^int jr(int rs){$/;"	f
la	ascommand.c	/^char * la(char * tokens[]){$/;"	f
lb	ascommand.c	/^char * lb(char * tokens[]){$/;"	f
lb	emcommand.c	/^int lb(int base , int rt, int offset){$/;"	f
lh	ascommand.c	/^char * lh(char * tokens[]){$/;"	f
lineno	aslib.c	/^unsigned int lineno; $/;"	v
location	emcommand.c	/^} location;$/;"	t	typeref:struct:_location	file:
loglocation	emcommand.c	/^location loglocation = {.x = 21, .y = 0}; $/;"	v
logstring	emcommand.c	/^void logstring(const char *str, int i){$/;"	f
lower_16_byte	aslib.c	/^int lower_16_byte(int word32bit){$/;"	f
lower_byte	aslib.c	/^int lower_byte(int word16bit){$/;"	f
lowertoint	aslib.c	/^unsigned int lowertoint(char * bits){$/;"	f
lui	ascommand.c	/^char * lui(char * tokens[]){$/;"	f
lui	emcommand.c	/^int lui(int rt, int imm){$/;"	f
lw	ascommand.c	/^char * lw(char * tokens[]){$/;"	f
lw	emcommand.c	/^int lw(int base , int rt, int offset){$/;"	f
main	assembler.c	/^int main(int argc, const char *argv[])$/;"	f
main	emulator.c	/^int main(int argc, const char *argv[])$/;"	f
memindex	emulator.c	/^unsigned int memindex = 0;$/;"	v
memory	aslib.c	/^unsigned short  memory[MIF_FILE_SIZE];	$/;"	v
memory	emcommand.c	/^unsigned short memory[MIF_FILE_SIZE]; $/;"	v
mult	ascommand.c	/^char * mult(char * tokens[]){$/;"	f
mult	emcommand.c	/^int mult(int rs, int rt){$/;"	f
name	aslib.h	/^	char * name; $/;"	m	struct:_inst_info
name	aslib.h	/^	char * name; $/;"	m	struct:_symbol_table
name	aslib.h	/^	char * name;$/;"	m	struct:inst_table
newstr	aslib.c	/^char * newstr(int len){$/;"	f
newstr	emcommand.c	/^char * newstr(int len){$/;"	f
nop	ascommand.c	/^char * nop(char * tokens[]){$/;"	f
nop	emcommand.c	/^int nop(){$/;"	f
nor	ascommand.c	/^char * nor(char * tokens[]){$/;"	f
nor	emcommand.c	/^int nor(int rs, int rt, int rd){$/;"	f
offsetint	emcommand.c	/^unsigned int offsetint(char * bits){$/;"	f
opcodebits	aslib.h	/^	char * opcodebits; $/;"	m	struct:_inst
or	ascommand.c	/^char * or(char * tokens[]){$/;"	f
or	emcommand.c	/^int or(int rs, int rt, int rd){$/;"	f
ori	ascommand.c	/^char * ori(char * tokens[]){$/;"	f
ori	emcommand.c	/^int ori(int rs, int rt, int imm){$/;"	f
outputMIFfile	aslib.c	/^void outputMIFfile(FILE *MIFfile) {$/;"	f
pc	emcommand.c	/^unsigned int pc; $/;"	v
pr_base_rt_inst_index	simpleoutput.c	/^void pr_base_rt_inst_index(const char * inst, int rt, int inst_index){$/;"	f
pr_base_rt_offset	simpleoutput.c	/^void pr_base_rt_offset(const char * inst, int base, int rt, int offset){$/;"	f
pr_inst_index	simpleoutput.c	/^void pr_inst_index(const char * inst, int inst_index){$/;"	f
pr_nop	simpleoutput.c	/^void pr_nop(){$/;"	f
pr_rs	simpleoutput.c	/^void pr_rs(const char * inst, int rs){$/;"	f
pr_rs_rt	simpleoutput.c	/^void pr_rs_rt(const char * inst, int rs, int rt){$/;"	f
pr_rs_rt_imm	simpleoutput.c	/^void pr_rs_rt_imm(const char * inst, int rs, int rt, int imm){$/;"	f
pr_rs_rt_offset	simpleoutput.c	/^void pr_rs_rt_offset(const char * inst, int rs, int rt, int offset){$/;"	f
pr_rs_rt_rd	simpleoutput.c	/^void pr_rs_rt_rd(const char * inst, int rs, int rt, int rd){$/;"	f
pr_rt_imm	simpleoutput.c	/^void pr_rt_imm(const char * inst, int rt, int imm){$/;"	f
pr_rt_rd_sa	simpleoutput.c	/^void pr_rt_rd_sa(const char * inst, int rt, int rd, int sa){$/;"	f
printHeaders	aslib.c	/^void printHeaders(FILE *MIFfile){$/;"	f
printTail	aslib.c	/^void printTail(FILE *MIFfile){$/;"	f
print_heap	emulator.c	/^void print_heap(){$/;"	f
print_output	emcommand.c	/^void print_output(const char *str){$/;"	f
processLine	assembler.c	/^char *  processLine(char * line, FILE *rfile, FILE *MIFfile){$/;"	f
ptr	aslib.h	/^	char * (*ptr)(char *[]);$/;"	m	struct:inst_table
ptr	aslib.h	/^void (*ptr)(int, int);$/;"	v
put_sym	aslib.c	/^unsigned put_sym(const char * name, unsigned int loc){$/;"	f
rdest	aslib.h	/^	char * rdest; $/;"	m	struct:_inst_info
refresh_state	emcommand.c	/^void refresh_state(){$/;"	f
reg	aslib.h	/^} reg; $/;"	t	typeref:struct:_register
regint	emcommand.c	/^unsigned int regint(char * bits){$/;"	f
register_data	aslib.h	/^static reg register_data[] =  {$/;"	v
register_name	aslib.c	/^char * register_name(char * input){$/;"	f
register_offset	aslib.c	/^int register_offset(char * input){$/;"	f
registerbits	aslib.h	/^	char * registerbits; $/;"	m	struct:_register
registername	aslib.h	/^	char * registername; $/;"	m	struct:_register
registernumber	aslib.h	/^	char * registernumber; $/;"	m	struct:_register
registers	emcommand.c	/^int registers[32]; $/;"	v
regmap	emcommand.c	/^char *regmap[32] =  {$/;"	v
removeSpaces	aslib.c	/^char * removeSpaces(const char * s) {$/;"	f
rsrc	aslib.h	/^	char * rsrc; $/;"	m	struct:_inst_info
sb	ascommand.c	/^char * sb(char * tokens[]){$/;"	f
sb	emcommand.c	/^int sb(int base , int rt, int offset){$/;"	f
sll	ascommand.c	/^char * sll(char * tokens[]){$/;"	f
sll	emcommand.c	/^int sll(int rt, int rd, int sa){$/;"	f
sllv	ascommand.c	/^char * sllv(char * tokens[]){$/;"	f
sllv	emcommand.c	/^int sllv(int rs, int rt, int rd){$/;"	f
slt	ascommand.c	/^char * slt(char * tokens[]){$/;"	f
slt	emcommand.c	/^int slt(int rs, int rt, int rd){$/;"	f
slti	ascommand.c	/^char * slti(char * tokens[]){$/;"	f
slti	emcommand.c	/^int slti(int rs, int rt, int imm){$/;"	f
sp	emcommand.c	/^int sp = STACK_BASE; $/;"	v
sra	ascommand.c	/^char * sra(char * tokens[]){$/;"	f
sra	emcommand.c	/^int sra(int rt, int rd, int sa){$/;"	f
srav	ascommand.c	/^char * srav(char * tokens[]){$/;"	f
srav	emcommand.c	/^int srav(int rs, int rt, int rd){$/;"	f
srl	ascommand.c	/^char * srl(char * tokens[]){$/;"	f
srl	emcommand.c	/^int srl(int rt, int rd, int sa){$/;"	f
srlv	ascommand.c	/^char * srlv(char * tokens[]){$/;"	f
srlv	emcommand.c	/^int srlv(int rs, int rt, int rd){$/;"	f
store_number	assembler.c	/^int store_number(char *str){$/;"	f
sub	ascommand.c	/^char * sub(char * tokens[]){$/;"	f
sub	emcommand.c	/^int sub(int rs, int rt, int rd){$/;"	f
sw	ascommand.c	/^char * sw(char * tokens[]){$/;"	f
sw	emcommand.c	/^int sw(int base , int rt, int offset){$/;"	f
sym_skip_list	assembler.c	/^static char *sym_skip_list[100] = {$/;"	v	file:
symbol_table	aslib.h	/^} symbol_table;$/;"	t	typeref:struct:_symbol_table
symbols	aslib.c	/^symbol_table symbols[MAX_SYMBOL_SIZE];$/;"	v
symmaxindex	aslib.c	/^unsigned int symmaxindex; $/;"	v
type2	ascommand.c	/^char * type2(char * arg0, char * arg1){$/;"	f
type3	ascommand.c	/^char * type3(char * arg0, char * arg1, char * arg2){$/;"	f
type4	ascommand.c	/^char * type4(char * arg0, char * arg1, char *arg2, char *arg3){$/;"	f
type5	ascommand.c	/^char * type5(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4){$/;"	f
type6	ascommand.c	/^char * type6(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4, char *arg5){$/;"	f
verify_atoi	ascommand.c	/^int verify_atoi(char *token){$/;"	f
waitmaybe	emulator.c	/^void waitmaybe(const char * inst){$/;"	f
wordaddress	aslib.c	/^unsigned int wordaddress; $/;"	v
x	emcommand.c	/^	int x, y; $/;"	m	struct:_location	file:
xor	ascommand.c	/^char * xor(char * tokens[]){$/;"	f
xor	emcommand.c	/^int xor(int rs, int rt, int rd){$/;"	f
xori	ascommand.c	/^char * xori(char * tokens[]){$/;"	f
xori	emcommand.c	/^int xori(int rs, int rt, int imm){$/;"	f
y	emcommand.c	/^	int x, y; $/;"	m	struct:_location	file:
