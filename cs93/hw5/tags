!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFLEN	ascommand.c	8;"	d	file:
DEBUG	assembler.c	14;"	d	file:
INSTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	g
INSTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	t	typeref:enum:INSTYPE
ITYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
J	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
MAX_SYMBOL_SIZE	aslib.h	5;"	d
MEMORY_MAX	emcommand.h	1;"	d
MIF_FILE_SIZE	aslib.h	4;"	d
REG_IOBUFFER_1	assembler.c	18;"	d	file:
REG_IOBUFFER_2	assembler.c	19;"	d	file:
REG_IOCONTROL	assembler.c	17;"	d	file:
RTYPE	aslib.h	/^typedef  enum INSTYPE {RTYPE, ITYPE, J} INSTYPE; $/;"	e	enum:INSTYPE
STACK_BASE	assembler.c	16;"	d	file:
_GNU_SOURCE	assembler.c	5;"	d	file:
_break	ascommand.c	/^char * _break(char * tokens[]){$/;"	f
_div	ascommand.c	/^char * _div(char * tokens[]){$/;"	f
_encoding	aslib.h	/^typedef struct _encoding { $/;"	s
_inst	aslib.h	/^typedef struct _inst { $/;"	s
_inst_info	aslib.h	/^typedef struct _inst_info {$/;"	s
_location	emcommand.c	/^typedef struct _location {$/;"	s	file:
_register	aslib.h	/^typedef struct _register {$/;"	s
_symbol_table	aslib.h	/^typedef struct _symbol_table {$/;"	s
add	ascommand.c	/^char * add(char * tokens[]){$/;"	f
add	emcommand.c	/^int add(int rs, int rt, int rd){$/;"	f
addi	ascommand.c	/^char * addi(char * tokens[]){$/;"	f
addi	emcommand.c	/^int addi(int rs, int rt, int imm){$/;"	f
addiu	ascommand.c	/^char * addiu(char * tokens[]){$/;"	f
addiu	emcommand.c	/^int addiu(int rs, int rt, int imm){$/;"	f
addu	ascommand.c	/^char * addu(char * tokens[]){$/;"	f
addu	emcommand.c	/^int addu(int rs, int rt, int rd){$/;"	f
aluopcodebits	aslib.h	/^	char * aluopcodebits; $/;"	m	struct:_inst
and	ascommand.c	/^char * and(char * tokens[]){$/;"	f
and	emcommand.c	/^int and(int rs, int rt, int rd){$/;"	f
andi	ascommand.c	/^char * andi(char * tokens[]){$/;"	f
andi	emcommand.c	/^int andi(int rs, int rt, int imm){$/;"	f
beq	ascommand.c	/^char * beq(char * tokens[]){$/;"	f
beq	emcommand.c	/^int beq(int rs, int rt, int offset){$/;"	f
bgez	ascommand.c	/^char * bgez(char * tokens[]){$/;"	f
bgez	emcommand.c	/^int bgez(int rs, int offset){$/;"	f
bgezal	ascommand.c	/^char * bgezal(char * tokens[]){$/;"	f
bgezal	emcommand.c	/^int bgezal(int rs, int offset){$/;"	f
bgtz	ascommand.c	/^char * bgtz(char * tokens[]){$/;"	f
bgtz	emcommand.c	/^int bgtz(int rs, int offset){$/;"	f
bin16toint	aslib.c	/^unsigned int  bin16toint(char * bits){$/;"	f
bin32toint	aslib.c	/^unsigned int bin32toint(char * bits){$/;"	f
binary	aslib.h	/^	char * binary; $/;"	m	struct:_encoding
binaryToHex	aslib.c	/^char * binaryToHex(char * binary){$/;"	f
blez	ascommand.c	/^char * blez(char * tokens[]){$/;"	f
blez	emcommand.c	/^int blez(int rs, int offset){$/;"	f
bltz	ascommand.c	/^char * bltz(char * tokens[]){$/;"	f
bltz	emcommand.c	/^int bltz(int rs, int offset){$/;"	f
bltzal	ascommand.c	/^char * bltzal(char * tokens[]){$/;"	f
bltzal	emcommand.c	/^int bltzal(int rs, int offset){$/;"	f
bne	ascommand.c	/^char * bne(char * tokens[]){$/;"	f
bne	emcommand.c	/^int bne(int rs, int rt, int offset){$/;"	f
cleanLine	aslib.c	/^void cleanLine(char **lineptr){$/;"	f
command	emcommand.c	/^location command = {.x = 20, .y = 0}; $/;"	v
copz	ascommand.c	/^char * copz(char * tokens[]){$/;"	f
divu	ascommand.c	/^char * divu(char * tokens[]){$/;"	f
do_first_pass	assembler.c	/^void do_first_pass(int argc, const char *argv[]){$/;"	f
do_second_pass	assembler.c	/^void do_second_pass(int argc, const char *argv[]){$/;"	f
doinst	emcommand.c	/^int doinst(char * inst){$/;"	f
dump_memory	aslib.c	/^void dump_memory() { $/;"	f
dump_sym_table	aslib.c	/^unsigned dump_sym_table(){$/;"	f
encoding	aslib.h	/^} encoding; $/;"	t	typeref:struct:_encoding
encoding_data	aslib.h	/^static encoding encoding_data[] = { $/;"	v
eval_exp	aslib.c	/^int eval_exp(char *expWithParen, int *error)$/;"	f
eval_register	aslib.c	/^char * eval_register(char *expWithParen)$/;"	f
exitOnNull	aslib.c	/^void exitOnNull(void * ptr, char * msg){$/;"	f
filter	aslib.c	/^int filter(char **lineptr){$/;"	f
found_sym	aslib.c	/^unsigned found_sym(const char * name) {$/;"	f
function_type	aslib.h	/^typedef char * (*function_type)(char *[]); $/;"	t
get	emcommand.c	/^unsigned get(int num, int start, int end){$/;"	f
getAluOpcodeBits	aslib.c	/^char * getAluOpcodeBits(char *name){$/;"	f
getBits	aslib.c	/^char * getBits(int num, unsigned int SIZE) { $/;"	f
getBits	emcommand.c	/^char * getBits(int num, unsigned int SIZE) { $/;"	f
getBits1	emcommand.c	/^char * getBits1(int num, unsigned int SIZE) { $/;"	f
getFiles	aslib.c	/^void getFiles(int argc, const char * argv[], $/;"	f
getFiles	emulator.c	/^void getFiles(int argc, const char * argv[], FILE **rfile){$/;"	f
getFunc	assembler.c	/^function_type getFunc(const char * name){$/;"	f
getOpcodebits	aslib.c	/^char * getOpcodebits(char *name){$/;"	f
getRegisterBits	aslib.c	/^char * getRegisterBits(char *registername){$/;"	f
getTokens	aslib.c	/^void getTokens(const char * line, char * tokens[]){$/;"	f
get_sym_address	aslib.c	/^unsigned int get_sym_address(const char * name){$/;"	f
getasciiz	aslib.c	/^char * getasciiz(const char *input){$/;"	f
getlabel	aslib.c	/^char * getlabel(const char *string){$/;"	f
hex	aslib.h	/^	char * hex; $/;"	m	struct:_encoding
hextoint	aslib.c	/^unsigned int hextoint(char * hex){$/;"	f
hextoint	emcommand.c	/^unsigned int hextoint(char * hex){$/;"	f
higher_byte	aslib.c	/^int higher_byte(int word16bit) {$/;"	f
highertoint	aslib.c	/^unsigned int highertoint(char * bits){$/;"	f
ifParen	aslib.c	/^unsigned int ifParen(const char *exp){$/;"	f
immint	emcommand.c	/^unsigned int immint(char * bits){$/;"	f
index	aslib.h	/^	unsigned int index; $/;"	m	struct:_symbol_table
inst	aslib.h	/^} inst; $/;"	t	typeref:struct:_inst
inst_data	aslib.h	/^static inst inst_data[100] = {$/;"	v
inst_info	aslib.h	/^} inst_info;$/;"	t	typeref:struct:_inst_info
inst_table	aslib.h	/^struct inst_table {$/;"	s
instint	emcommand.c	/^unsigned int instint(char * bits){$/;"	f
instname	aslib.h	/^	char * instname; $/;"	m	struct:_inst
insts	assembler.c	/^struct inst_table insts[] = {$/;"	v	typeref:struct:inst_table
ir	emcommand.c	/^unsigned int ir; $/;"	v
isValidInt	assembler.c	/^int isValidInt(const char *str, int base, int *value)$/;"	f
is_in_skip_list	assembler.c	/^int is_in_skip_list(char *sym){$/;"	f
is_valid_inst	assembler.c	/^unsigned int is_valid_inst(const char *line){$/;"	f
isasciiz	aslib.c	/^int isasciiz(const char * string){$/;"	f
isempty	aslib.c	/^int isempty(const char *string){$/;"	f
islabel	aslib.c	/^int islabel(const char * string){$/;"	f
j	ascommand.c	/^char * j(char * tokens[]){$/;"	f
j	emcommand.c	/^int j(int inst_index){$/;"	f
jal	ascommand.c	/^char * jal(char * tokens[]){$/;"	f
jal	emcommand.c	/^int jal(int inst_index){$/;"	f
jalr	ascommand.c	/^char * jalr(char * tokens[]){$/;"	f
jalr	emcommand.c	/^int jalr(int rs, int rd){$/;"	f
jr	ascommand.c	/^char * jr(char * tokens[]){$/;"	f
jr	emcommand.c	/^int jr(int rs){$/;"	f
la	ascommand.c	/^char * la(char * tokens[]){$/;"	f
lb	ascommand.c	/^char * lb(char * tokens[]){$/;"	f
lb	emcommand.c	/^int lb(int base , int rt, int offset){$/;"	f
lbu	ascommand.c	/^char * lbu(char * tokens[]){$/;"	f
lbu	emcommand.c	/^int lbu(int base , int rt, int offset){$/;"	f
lh	ascommand.c	/^char * lh(char * tokens[]){$/;"	f
lh	emcommand.c	/^int lh(int base , int rt, int offset){$/;"	f
lhu	ascommand.c	/^char * lhu(char * tokens[]){$/;"	f
lhu	emcommand.c	/^int lhu(int base , int rt, int offset){$/;"	f
lineno	aslib.c	/^unsigned int lineno; $/;"	v
location	emcommand.c	/^} location;$/;"	t	typeref:struct:_location	file:
lower_byte	aslib.c	/^int lower_byte(int word16bit){$/;"	f
lowertoint	aslib.c	/^unsigned int lowertoint(char * bits){$/;"	f
lui	ascommand.c	/^char * lui(char * tokens[]){$/;"	f
lui	emcommand.c	/^int lui(int rt, int imm){$/;"	f
lw	ascommand.c	/^char * lw(char * tokens[]){$/;"	f
lw	emcommand.c	/^int lw(int base , int rt, int offset){$/;"	f
lwcz	ascommand.c	/^char * lwcz(char * tokens[]){$/;"	f
lwl	ascommand.c	/^char * lwl(char * tokens[]){$/;"	f
lwl	emcommand.c	/^int lwl(int base , int rt, int offset){$/;"	f
lwr	ascommand.c	/^char * lwr(char * tokens[]){$/;"	f
lwr	emcommand.c	/^int lwr(int base , int rt, int offset){$/;"	f
main	assembler.c	/^int main(int argc, const char *argv[])$/;"	f
main	emulator.c	/^int main(int argc, const char *argv[])$/;"	f
memindex	emulator.c	/^unsigned int memindex = 0;$/;"	v
memory	aslib.c	/^unsigned short  memory[MIF_FILE_SIZE];	$/;"	v
memory	emcommand.c	/^unsigned short memory[MEMORY_MAX]; $/;"	v
mfhi	ascommand.c	/^char * mfhi(char * tokens[]){$/;"	f
mflo	ascommand.c	/^char * mflo(char * tokens[]){$/;"	f
mthi	ascommand.c	/^char * mthi(char * tokens[]){$/;"	f
mtlo	ascommand.c	/^char * mtlo(char * tokens[]){$/;"	f
mult	ascommand.c	/^char * mult(char * tokens[]){$/;"	f
multu	ascommand.c	/^char * multu(char * tokens[]){$/;"	f
name	aslib.h	/^	char * name; $/;"	m	struct:_inst_info
name	aslib.h	/^	char * name; $/;"	m	struct:_symbol_table
name	aslib.h	/^	char * name;$/;"	m	struct:inst_table
newstr	aslib.c	/^char * newstr(int len){$/;"	f
newstr	emcommand.c	/^char * newstr(int len){$/;"	f
nop	ascommand.c	/^char * nop(char * tokens[]){$/;"	f
nor	ascommand.c	/^char * nor(char * tokens[]){$/;"	f
nor	emcommand.c	/^int nor(int rs, int rt, int rd){$/;"	f
offsetint	emcommand.c	/^unsigned int offsetint(char * bits){$/;"	f
opcodebits	aslib.h	/^	char * opcodebits; $/;"	m	struct:_inst
or	ascommand.c	/^char * or(char * tokens[]){$/;"	f
or	emcommand.c	/^int or(int rs, int rt, int rd){$/;"	f
ori	ascommand.c	/^char * ori(char * tokens[]){$/;"	f
ori	emcommand.c	/^int ori(int rs, int rt, int imm){$/;"	f
outputMIFfile	aslib.c	/^void outputMIFfile(FILE *MIFfile) {$/;"	f
pc	emcommand.c	/^unsigned int pc; $/;"	v
pr_reg_other	emcommand.c	/^void pr_reg_other(const char * inst, int reg, int other){$/;"	f
pr_reg_reg_other	emcommand.c	/^void pr_reg_reg_other(const char * inst, int reg1, int reg2, int other){$/;"	f
printHeaders	aslib.c	/^void printHeaders(FILE *MIFfile){$/;"	f
printTail	aslib.c	/^void printTail(FILE *MIFfile){$/;"	f
print_output	emcommand.c	/^void print_output(const char *str){$/;"	f
processLine	assembler.c	/^char *  processLine(char * line, FILE *rfile, FILE *MIFfile){$/;"	f
ptr	aslib.h	/^	char * (*ptr)(char *[]);$/;"	m	struct:inst_table
ptr	aslib.h	/^void (*ptr)(int, int);$/;"	v
put_sym	aslib.c	/^unsigned put_sym(const char * name, unsigned int loc){$/;"	f
rdest	aslib.h	/^	char * rdest; $/;"	m	struct:_inst_info
refresh_state	emcommand.c	/^void refresh_state(){$/;"	f
reg	aslib.h	/^} reg; $/;"	t	typeref:struct:_register
regint	emcommand.c	/^unsigned int regint(char * bits){$/;"	f
register_data	aslib.h	/^static reg register_data[] =  {$/;"	v
register_name	aslib.c	/^char * register_name(char * input){$/;"	f
register_offset	aslib.c	/^int register_offset(char * input){$/;"	f
registerbits	aslib.h	/^	char * registerbits; $/;"	m	struct:_register
registername	aslib.h	/^	char * registername; $/;"	m	struct:_register
registernumber	aslib.h	/^	char * registernumber; $/;"	m	struct:_register
registers	emcommand.c	/^int registers[32]; $/;"	v
removeSpaces	aslib.c	/^char * removeSpaces(const char * s) {$/;"	f
rsrc	aslib.h	/^	char * rsrc; $/;"	m	struct:_inst_info
sb	ascommand.c	/^char * sb(char * tokens[]){$/;"	f
sb	emcommand.c	/^int sb(int base , int rt, int offset){$/;"	f
sh	ascommand.c	/^char * sh(char * tokens[]){$/;"	f
sh	emcommand.c	/^int sh(int base , int rt, int offset){$/;"	f
sll	ascommand.c	/^char * sll(char * tokens[]){$/;"	f
sll	emcommand.c	/^int sll(int rt, int rd, int sa){$/;"	f
sllv	ascommand.c	/^char * sllv(char * tokens[]){$/;"	f
sllv	emcommand.c	/^int sllv(int rs, int rt, int rd){$/;"	f
slt	ascommand.c	/^char * slt(char * tokens[]){$/;"	f
slt	emcommand.c	/^int slt(int rs, int rt, int rd){$/;"	f
slti	ascommand.c	/^char * slti(char * tokens[]){$/;"	f
slti	emcommand.c	/^int slti(int rs, int rt, int imm){$/;"	f
sltiu	ascommand.c	/^char * sltiu(char * tokens[]){$/;"	f
sltiu	emcommand.c	/^int sltiu(int rs, int rt, int imm){$/;"	f
sltu	ascommand.c	/^char * sltu(char * tokens[]){$/;"	f
sltu	emcommand.c	/^int sltu(int rs, int rt, int rd){$/;"	f
sp	assembler.c	/^static int sp = STACK_BASE; $/;"	v	file:
sra	ascommand.c	/^char * sra(char * tokens[]){$/;"	f
sra	emcommand.c	/^int sra(int rt, int rd, int sa){$/;"	f
srav	ascommand.c	/^char * srav(char * tokens[]){$/;"	f
srav	emcommand.c	/^int srav(int rs, int rt, int rd){$/;"	f
srl	ascommand.c	/^char * srl(char * tokens[]){$/;"	f
srl	emcommand.c	/^int srl(int rt, int rd, int sa){$/;"	f
srlv	ascommand.c	/^char * srlv(char * tokens[]){$/;"	f
srlv	emcommand.c	/^int srlv(int rs, int rt, int rd){$/;"	f
store_string	assembler.c	/^int store_string(char *str){$/;"	f
sub	ascommand.c	/^char * sub(char * tokens[]){$/;"	f
sub	emcommand.c	/^int sub(int rs, int rt, int rd){$/;"	f
subu	ascommand.c	/^char * subu(char * tokens[]){$/;"	f
subu	emcommand.c	/^int subu(int rs, int rt, int rd){$/;"	f
sw	ascommand.c	/^char * sw(char * tokens[]){$/;"	f
sw	emcommand.c	/^int sw(int base , int rt, int offset){$/;"	f
swcz	ascommand.c	/^char * swcz(char * tokens[]){$/;"	f
swl	ascommand.c	/^char * swl(char * tokens[]){$/;"	f
swl	emcommand.c	/^int swl(int base , int rt, int offset){$/;"	f
swr	ascommand.c	/^char * swr(char * tokens[]){$/;"	f
swr	emcommand.c	/^int swr(int base , int rt, int offset){$/;"	f
sym_skip_list	assembler.c	/^static char *sym_skip_list[100] = {$/;"	v	file:
symbol_table	aslib.h	/^} symbol_table;$/;"	t	typeref:struct:_symbol_table
symbols	aslib.c	/^symbol_table symbols[MAX_SYMBOL_SIZE];$/;"	v
symmaxindex	aslib.c	/^unsigned int symmaxindex; $/;"	v
syscall	ascommand.c	/^char * syscall(char * tokens[]){$/;"	f
type2	ascommand.c	/^char * type2(char * arg0, char * arg1){$/;"	f
type3	ascommand.c	/^char * type3(char * arg0, char * arg1, char * arg2){$/;"	f
type4	ascommand.c	/^char * type4(char * arg0, char * arg1, char *arg2, char *arg3){$/;"	f
type5	ascommand.c	/^char * type5(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4){$/;"	f
type6	ascommand.c	/^char * type6(char * arg0, char * arg1, char *arg2, char *arg3, char *arg4, char *arg5){$/;"	f
verify_atoi	ascommand.c	/^int verify_atoi(char *token){$/;"	f
wordaddress	aslib.c	/^unsigned int wordaddress; $/;"	v
x	emcommand.c	/^	int x, y; $/;"	m	struct:_location	file:
xor	ascommand.c	/^char * xor(char * tokens[]){$/;"	f
xor	emcommand.c	/^int xor(int rs, int rt, int rd){$/;"	f
xori	ascommand.c	/^char * xori(char * tokens[]){$/;"	f
xori	emcommand.c	/^int xori(int rs, int rt, int imm){$/;"	f
y	emcommand.c	/^	int x, y; $/;"	m	struct:_location	file:
