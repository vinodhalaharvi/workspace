Good links: 
http://web.stanford.edu/class/ee282h/projects/info/isa.html
https://ece.uwaterloo.ca/~ece222/ARM/ARM7-TDMI-manual-pt3.pdf
http://math-atlas.sourceforge.net/devel/assembly/mips-iv.pdf


25 - 21 rs 
20 - 16 rt 
15 - 11 rd 

IR = MEM[PC]
PC = PC + 4

A = RF[IR[25 - 21]]
B = RF[IR[20 - 16]]

res = A op B 

RF[IR[15 - 11]]  = res


MIPS Instruction class
Thu Sep 25 12:19:32 UTC 2014
6 lectures from IITD
	machine instructions
	pipelining
	memory mapped I/O
	multiplication
	division

#Cornell Computer architecture code git repo
	ECE 4750 Computer Architecture Fall 2014
	https://github.com/cbatten/x/blob/master/code-lab1-random-testing.v
	http://www.csl.cornell.edu/courses/ece4750/
	http://www.csl.cornell.edu/courses/ece4750/handouts/


The goal of a pipelined architecture is to complete an instruction every clock cycle. To maintain this rate, the pipeline must be full of instructions at all times. The branch delay slot is a side effect of pipelined architectures due to the branch hazard, i.e. the fact that the branch would not be resolved until the instruction has worked its way through the pipeline. A simple design would insert stalls into the pipeline after a branch instruction until the new branch target address is computed and loaded into the program counter. Each cycle where a stall is inserted is considered one branch delay slot. A more sophisticated design would execute program instructions which are not dependent on the result of the branch instruction. This optimization can be performed in software at compile time by moving instructions into branch delay slots in the in-memory instruction stream, if the hardware supports this. Another side effect is that special handling should be taken care of managing breakpoint on instructions as well as stepping while debugging within branch delay slot.

The ideal number of branch delay slots in a particular pipeline implementation is dictated by the number of pipeline stages, the presence of register forwarding, what stage of the pipeline the branch conditions are computed, whether or not a branch target buffer (BTB) is used and many other factors. Software compatibility requirements dictate that an architecture may not change the number of delay slots from one generation to the next. This inevitably requires that newer hardware implementations contain extra hardware to ensure that the architectural behavior is followed despite no longer being relevant.
